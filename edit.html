<!DOCTYPE html>
<html lang="nl">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Platformer Editor - Fixed Drag</title>
<style>
body { margin:0; overflow:hidden; background:#87CEEB; user-select:none; font-family:monospace; }
canvas { display:block; background:#87CEEB; cursor:crosshair; }
#jsonOutput { position:fixed; bottom:10px; left:10px; width:95%; height:120px; font-family:monospace; }
#controls { position:fixed; top:10px; left:10px; background:rgba(255,255,255,0.9); padding:10px; border-radius:8px; width:220px; }
#controls label { display:block; margin:5px 0; }
#guideToggle { cursor:pointer; color:blue; text-decoration:underline; margin-bottom:5px; }
#guide { display:none; background:#fff; padding:5px; border-radius:5px; margin-bottom:5px; font-size:12px; }
</style>
</head>
<body>
<canvas id="editorCanvas"></canvas>
<div id="controls">
  <div id="guideToggle">Handleiding â–¼</div>
  <div id="guide">
    <ul>
      <li>Links klikken = statisch platform toevoegen.</li>
      <li>M + klik = bewegend platform toevoegen.</li>
      <li>Rechtermuisklik = platform verwijderen.</li>
      <li>Slepen = verplaats platform/player.</li>
      <li>Resize handle (rood) = platform resizen.</li>
      <li>Shift + drag = camera bewegen.</li>
      <li>Bewegende platforms hebben blauwe lijn + pijltjes = begin/eind. Sleep ze om aan te passen.</li>
      <li>Snelheid slider = snelheid van geselecteerd bewegend platform.</li>
    </ul>
  </div>
  <label>Snelheid: <input type="range" id="speedSlider" min="0.005" max="0.1" step="0.005" value="0.02"></label>
</div>
<textarea id="jsonOutput" readonly></textarea>
<script>
const canvas=document.getElementById("editorCanvas");
const ctx=canvas.getContext("2d");
canvas.width=window.innerWidth;
canvas.height=window.innerHeight;

let platforms=[];
let movingPlatforms=[];
let playerStart={x:0,y:0};

let dragging=null;
let resizing=false;
let offset={x:0,y:0};
const handleSize=10;
let selectedMovingPlatform=null;
let selectedLineHandle=null;
let isMKey=false;
let isDragging=false; // <-- flag

// Camera
let cam={x:0,y:0};

// Guide toggle
const guideToggle=document.getElementById("guideToggle");
const guide=document.getElementById("guide");
guideToggle.addEventListener("click", ()=>{ guide.style.display=(guide.style.display==='none')?'block':'none'; });

// Draw function
function draw(){
  ctx.clearRect(0,0,canvas.width,canvas.height);
  ctx.fillStyle="green";
  ctx.fillRect(playerStart.x-cam.x-15, playerStart.y-cam.y-15,30,30);

  // Static platforms
  platforms.forEach(p=>{
    ctx.fillStyle="#654321";
    ctx.fillRect(p.x-cam.x-p.w/2,p.y-cam.y-p.h/2,p.w,p.h);
    ctx.strokeStyle="#382D1B"; ctx.strokeRect(p.x-cam.x-p.w/2,p.y-cam.y-p.h/2,p.w,p.h);
    ctx.fillStyle="red";
    ctx.fillRect(p.x-cam.x+p.w/2-handleSize,p.y-cam.y+p.h/2-handleSize,handleSize,handleSize);
  });

  // Moving platforms
  movingPlatforms.forEach(p=>{
    ctx.fillStyle="orange";
    ctx.fillRect(p.x-cam.x-p.w/2,p.y-cam.y-p.h/2,p.w,p.h);
    ctx.strokeStyle="#FF8C00"; ctx.strokeRect(p.x-cam.x-p.w/2,p.y-cam.y-p.h/2,p.w,p.h);
    ctx.fillStyle="red";
    ctx.fillRect(p.x-cam.x+p.w/2-handleSize,p.y-cam.y+p.h/2-handleSize,handleSize,handleSize);

    // movement line
    if(p.moveAxis==='x'){
      ctx.strokeStyle="blue"; ctx.lineWidth=2;
      ctx.beginPath(); ctx.moveTo(p.startX-cam.x, p.y-cam.y); ctx.lineTo(p.endX-cam.x, p.y-cam.y); ctx.stroke();
      ctx.fillStyle="blue";
      ctx.fillRect(p.startX-cam.x-5,p.y-cam.y-5,10,10);
      ctx.fillRect(p.endX-cam.x-5,p.y-cam.y-5,10,10);
    } else {
      ctx.strokeStyle="blue"; ctx.lineWidth=2;
      ctx.beginPath(); ctx.moveTo(p.x-cam.x,p.startY-cam.y); ctx.lineTo(p.x-cam.x,p.endY-cam.y); ctx.stroke();
      ctx.fillStyle="blue";
      ctx.fillRect(p.x-cam.x-5,p.startY-cam.y-5,10,10);
      ctx.fillRect(p.x-cam.x-5,p.endY-cam.y-5,10,10);
    }
  });

  updateJSON();
}

function updateJSON(){
  const json={playerStart:{x:playerStart.x,y:playerStart.y},platforms:platforms,movingPlatforms:movingPlatforms};
  document.getElementById("jsonOutput").value=JSON.stringify(json,null,2);
}

function getMousePos(e){
  const rect=canvas.getBoundingClientRect();
  return {x:e.clientX-rect.left+cam.x, y:e.clientY-rect.top+cam.y};
}

// key M
document.addEventListener("keydown", e=>{ if(e.key==="m") isMKey=true; });
document.addEventListener("keyup", e=>{ if(e.key==="m") isMKey=false; });

// Mouse events
canvas.addEventListener("mousedown", e=>{
  isDragging=false; // reset
  const pos=getMousePos(e);
  if(pos.x>playerStart.x-15 && pos.x<playerStart.x+15 && pos.y>playerStart.y-15 && pos.y<playerStart.y+15){
    dragging="player"; offset={x:pos.x-playerStart.x,y:pos.y-playerStart.y}; return;
  }
  const allPlatforms=[...platforms,...movingPlatforms];
  for(let i=allPlatforms.length-1;i>=0;i--){
    const p=allPlatforms[i];
    if(pos.x>p.x+p.w/2-handleSize && pos.x<p.x+p.w/2 && pos.y>p.y+p.h/2-handleSize && pos.y<p.y+p.h/2){
      dragging=p; resizing=true; offset={x:p.x+p.w/2-pos.x, y:p.y+p.h/2-pos.y}; 
      if(movingPlatforms.includes(p)) selectedMovingPlatform=p; return;
    }
    if(pos.x>p.x-p.w/2 && pos.x<p.x+p.w/2 && pos.y>p.y-p.h/2 && pos.y<p.y+p.h/2){
      dragging=p; resizing=false; offset={x:pos.x-p.x, y:pos.y-p.y};
      if(movingPlatforms.includes(p)) selectedMovingPlatform=p; return;
    }
  }
  movingPlatforms.forEach(p=>{
    if(p.moveAxis==='x'){
      if(pos.x>p.startX-5 && pos.x<p.startX+5 && pos.y>p.y-5 && pos.y<p.y+5){ selectedLineHandle='start'; dragging=p; return; }
      if(pos.x>p.endX-5 && pos.x<p.endX+5 && pos.y>p.y-5 && pos.y<p.y+5){ selectedLineHandle='end'; dragging=p; return; }
    } else {
      if(pos.y>p.startY-5 && pos.y<p.startY+5 && pos.x>p.x-5 && pos.x<p.x+5){ selectedLineHandle='start'; dragging=p; return; }
      if(pos.y>p.endY-5 && pos.y<p.endY+5 && pos.x>p.x-5 && pos.x<p.x+5){ selectedLineHandle='end'; dragging=p; return; }
    }
  });
});

canvas.addEventListener("mousemove", e=>{
  const pos=getMousePos(e);
  if(dragging){
    isDragging=true;
    if(dragging==="player"){ playerStart.x=pos.x-offset.x; playerStart.y=pos.y-offset.y; }
    else if(resizing){ dragging.w=pos.x-(dragging.x-dragging.w/2)+offset.x; dragging.h=pos.y-(dragging.y-dragging.h/2)+offset.y; if(dragging.w<10) dragging.w=10; if(dragging.h<10) dragging.h=10; }
    else if(selectedLineHandle){
      if(dragging.moveAxis==='x'){ if(selectedLineHandle==='start') dragging.startX=pos.x; else dragging.endX=pos.x; }
      else { if(selectedLineHandle==='start') dragging.startY=pos.y; else dragging.endY=pos.y; }
    } else { dragging.x=pos.x-offset.x; dragging.y=pos.y-offset.y; }
    draw();
  } else if(e.shiftKey){ cam.x -= e.movementX; cam.y -= e.movementY; draw(); }
});

canvas.addEventListener("mouseup", e=>{ dragging=null; resizing=false; selectedLineHandle=null; selectedMovingPlatform=null; });

// Add platforms (only if not dragging)
canvas.addEventListener("click", e=>{
  if(isDragging) return; // <--- FIX: ignore click if we just dragged
  const pos=getMousePos(e);
  if(isMKey){
    movingPlatforms.push({x:pos.x,y:pos.y,w:100,h:20,moveAxis:'y',moveRange:50,speed:0.02,originalX:pos.x,originalY:pos.y,startX:pos.x,endX:pos.x,startY:pos.y,endY:pos.y});
  } else {
    platforms.push({x:pos.x,y:pos.y,w:100,h:20});
  }
  draw();
});

// Remove
canvas.addEventListener("contextmenu", e=>{
  e.preventDefault(); const pos=getMousePos(e);
  for(let i=platforms.length-1;i>=0;i--){ const p=platforms[i]; if(pos.x>p.x-p.w/2 && pos.x<p.x+p.w/2 && pos.y>p.y-p.h/2 && pos.y<p.y+p.h/2){ platforms.splice(i,1); draw(); return; } }
  for(let i=movingPlatforms.length-1;i>=0;i--){ const p=movingPlatforms[i]; if(pos.x>p.x-p.w/2 && pos.x<p.x+p.w/2 && pos.y>p.y-p.h/2 && pos.y<p.y+p.h/2){ movingPlatforms.splice(i,1); draw(); return; } }
});

// speed slider
document.getElementById("speedSlider").addEventListener("input", e=>{ if(selectedMovingPlatform) selectedMovingPlatform.speed=parseFloat(e.target.value); draw(); });

window.addEventListener("resize", ()=>{ canvas.width=window.innerWidth; canvas.height=window.innerHeight; draw(); });

draw();
</script>
</body>
</html>
