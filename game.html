<!DOCTYPE html>
<html lang="nl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>2D Platformer Physics - Stenen Patroon</title>
    <style>
        body { margin:0; overflow:hidden; background:#87CEEB; }
        canvas { display:block; background:#87CEEB; }
    </style>
</head>
<body>
<script src="https://cdn.jsdelivr.net/npm/matter-js@0.20.0/build/matter.min.js"></script>
<script>
const { Engine, Render, Runner, Bodies, World, Body, Events, Composite, Query } = Matter;

// Engine setup
const engine = Engine.create();
engine.world.gravity.y = 1.2;
const world = engine.world;

// Renderer
let width = window.innerWidth;
let height = window.innerHeight;
const render = Render.create({
    element: document.body,
    engine: engine,
    options: {
        width,
        height,
        wireframes: false,
        background: '#87CEEB'
    }
});
Render.run(render);
Runner.run(Runner.create(), engine);

// Functie om een stenen patroon te maken
function createStonePattern() {
    const patternCanvas = document.createElement('canvas');
    const patternContext = patternCanvas.getContext('2d');
    patternCanvas.width = 40;
    patternCanvas.height = 40;
    
    // Achtergrond kleur
    patternContext.fillStyle = '#654321';
    patternContext.fillRect(0, 0, 40, 40);
    
    // Lichte stenen
    patternContext.fillStyle = '#7B6E59';
    patternContext.fillRect(2, 2, 36, 16);
    patternContext.fillRect(2, 22, 16, 16);
    patternContext.fillRect(22, 22, 16, 16);

    // Donkere lijnen
    patternContext.strokeStyle = '#382D1B';
    patternContext.lineWidth = 1;
    patternContext.strokeRect(2, 2, 36, 16);
    patternContext.strokeRect(2, 22, 16, 16);
    patternContext.strokeRect(22, 22, 16, 16);

    return render.context.createPattern(patternCanvas, 'repeat');
}

const stonePattern = createStonePattern();

// Platforms & ground
const ground = Bodies.rectangle(width/2, height-50, width, 100, { 
    isStatic: true, 
    render:{ 
        fillStyle: stonePattern
    } 
});
const platforms = [
    Bodies.rectangle(400, 400, 300, 20, { 
        isStatic:true, 
        render:{ 
            fillStyle: stonePattern
        } 
    }),
    Bodies.rectangle(700, 300, 200, 20, { 
        isStatic:true, 
        render:{ 
            fillStyle: stonePattern
        } 
    }),
    Bodies.rectangle(1000, 500, 250, 20, { 
        isStatic:true, 
        render:{ 
            fillStyle: stonePattern
        } 
    })
];
World.add(world, [ground, ...platforms]);

// Player
const player = Bodies.rectangle(100, 200, 50, 50, { 
    restitution: 0.05, 
    friction: 0.01,
    frictionAir: 0.02,
    render: { 
        sprite: { 
            texture: 'https://threejs.org/examples/textures/crate.gif',
            xScale: 0.2,
            yScale: 0.2
        }
    }
});
World.add(world, player);

// Controls
const keys = { left:false, right:false, up:false, dash: false };
let isDashing = false;
let dashStartTime = 0;
let lastDashTime = 0;
const dashCooldown = 2000;
const dashDuration = 100;

document.addEventListener('keydown', e => {
    if(e.code==='ArrowLeft') keys.left=true;
    if(e.code==='ArrowRight') keys.right=true;
    if(e.code==='ArrowUp') keys.up=true;
    if(e.code==='ShiftLeft' || e.code==='ShiftRight') keys.dash=true;
});
document.addEventListener('keyup', e => {
    if(e.code==='ArrowLeft') keys.left=false;
    if(e.code==='ArrowRight') keys.right=false;
    if(e.code==='ArrowUp') keys.up=false;
    if(e.code==='ShiftLeft' || e.code==='ShiftRight') keys.dash=false;
});

// Functie om te controleren of de speler de grond raakt
function isPlayerOnGround() {
    const checkArea = Bodies.rectangle(player.position.x, player.bounds.max.y + 5, player.bounds.max.x - player.bounds.min.x, 10, { isSensor: true });
    const collisions = Query.collides(checkArea, Composite.allBodies(world));
    const onGround = collisions.some(collision => {
        return (collision.bodyA.isStatic || collision.bodyB.isStatic) && (collision.bodyA !== player && collision.bodyB !== player);
    });
    return onGround;
}

// Game loop
Events.on(engine, 'beforeUpdate', () => {
    const speed = 5;
    const dashSpeed = 15;
    
    const canDashNow = Date.now() - lastDashTime >= dashCooldown;

    if (keys.dash && !isDashing && canDashNow) {
        let dashDirection = 0;
        if (keys.left) dashDirection = -dashSpeed;
        if (keys.right) dashDirection = dashSpeed;

        if (dashDirection !== 0) {
            Body.setVelocity(player, { x: dashDirection, y: player.velocity.y });
            isDashing = true;
            dashStartTime = Date.now();
            lastDashTime = Date.now();
        }
    }
    
    if (isDashing && Date.now() - dashStartTime >= dashDuration) {
        isDashing = false;
        Body.setVelocity(player, { x: 0, y: player.velocity.y });
    }

    if (!isDashing) {
        const currentVelocityX = player.velocity.x;
        const targetVelocityX = (keys.right ? speed : 0) - (keys.left ? speed : 0);
        const newVelocityX = currentVelocityX + (targetVelocityX - currentVelocityX) * 0.2;
        Body.setVelocity(player, { x: newVelocityX, y: player.velocity.y });
    }

    if(keys.up && isPlayerOnGround()) {
        Body.setVelocity(player, { x: player.velocity.x, y: -15 });
    }
});

// Responsieve canvas
window.addEventListener('resize', () => {
    width = window.innerWidth;
    height = window.innerHeight;
    Render.lookAt(render, { min:{x:0,y:0}, max:{x:width, y:height} });
});
</script>
</body>
</html>
